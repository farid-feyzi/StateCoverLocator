package org.jfree.chart.renderer.category;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.util.PublicCloneable;
import org.jfree.chart.util.RectangleEdge;
import org.jfree.data.DataUtilities;
import org.jfree.data.Range;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.general.DatasetUtilities;
/** 
 * A renderer that draws stacked area charts for a                                                                                               {@link CategoryPlot}. The example shown here is generated by the <code>StackedAreaChartDemo1.java</code> program included in the JFreeChart Demo Collection: <br><br> <img src="../../../../../images/StackedAreaRendererSample.png" alt="StackedAreaRendererSample.png" />
 */
public class StackedAreaRenderer extends AreaRenderer implements Cloneable, PublicCloneable, Serializable {
  /** 
 * For serialization. 
 */
  private static final long serialVersionUID=-3595635038460823663L;
  /** 
 * A flag that controls whether the areas display values or percentages. 
 */
  private boolean renderAsPercentages;
  /** 
 * Creates a new renderer.
 */
  public StackedAreaRenderer(){
    this(false);
  }
  /** 
 * Creates a new renderer.
 * @param renderAsPercentages  a flag that controls whether the data valuesare rendered as percentages.
 */
  public StackedAreaRenderer(  boolean renderAsPercentages){
    super();
    this.renderAsPercentages=renderAsPercentages;
  }
  /** 
 * Returns <code>true</code> if the renderer displays each item value as a percentage (so that the stacked areas add to 100%), and <code>false</code> otherwise.
 * @return A boolean.
 * @since 1.0.3
 */
  public boolean getRenderAsPercentages(){
    return this.renderAsPercentages;
  }
  /** 
 * Sets the flag that controls whether the renderer displays each item value as a percentage (so that the stacked areas add to 100%), and sends a                                                                                               {@link RendererChangeEvent} to all registered listeners.
 * @param asPercentages  the flag.
 * @since 1.0.3
 */
  public void setRenderAsPercentages(  boolean asPercentages){
    this.renderAsPercentages=asPercentages;
    fireChangeEvent();
  }
  /** 
 * Returns the number of passes (<code>2</code>) required by this renderer. The first pass is used to draw the bars, the second pass is used to draw the item labels (if visible).
 * @return The number of passes required by the renderer.
 */
  public int getPassCount(){
    return 2;
  }
  /** 
 * Returns the range of values the renderer requires to display all the items from the specified dataset.
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @return The range (or <code>null</code> if the dataset is empty).
 */
  public Range findRangeBounds(  CategoryDataset dataset){
    if (this.renderAsPercentages) {
      return new Range(0.0,1.0);
    }
 else {
      return DatasetUtilities.findStackedRangeBounds(dataset);
    }
  }
  /** 
 * Draw a single data item.
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the data plot area.
 * @param plot  the plot.
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the data.
 * @param row  the row index (zero-based).
 * @param column  the column index (zero-based).
 * @param pass  the pass index.
 */
  public void drawItem(  Graphics2D g2,  CategoryItemRendererState state,  Rectangle2D dataArea,  CategoryPlot plot,  CategoryAxis domainAxis,  ValueAxis rangeAxis,  CategoryDataset dataset,  int row,  int column,  boolean selected,  int pass){
    Shape entityArea=null;
    EntityCollection entities=state.getEntityCollection();
    double y1=0.0;
    Number n=dataset.getValue(row,column);
    if (n != null) {
      y1=n.doubleValue();
    }
    double[] stack1=getStackValues(dataset,row,column);
    double xx1=domainAxis.getCategoryMiddle(column,getColumnCount(),dataArea,plot.getDomainAxisEdge());
    double y0=0.0;
    n=dataset.getValue(row,Math.max(column - 1,0));
    if (n != null) {
      y0=n.doubleValue();
    }
    double[] stack0=getStackValues(dataset,row,Math.max(column - 1,0));
    double xx0=domainAxis.getCategoryStart(column,getColumnCount(),dataArea,plot.getDomainAxisEdge());
    int itemCount=dataset.getColumnCount();
    double y2=0.0;
    n=dataset.getValue(row,Math.min(column + 1,itemCount - 1));
    if (n != null) {
      y2=n.doubleValue();
    }
    double[] stack2=getStackValues(dataset,row,Math.min(column + 1,itemCount - 1));
    double xx2=domainAxis.getCategoryEnd(column,getColumnCount(),dataArea,plot.getDomainAxisEdge());
    double xxLeft=xx0;
    double xxRight=xx2;
    double[] stackLeft=averageStackValues(stack0,stack1);
    double[] stackRight=averageStackValues(stack1,stack2);
    double[] adjStackLeft=adjustedStackValues(stack0,stack1);
    double[] adjStackRight=adjustedStackValues(stack1,stack2);
    float transY1;
    RectangleEdge edge1=plot.getRangeAxisEdge();
    GeneralPath left=new GeneralPath();
    GeneralPath right=new GeneralPath();
    if (y1 >= 0.0) {
      transY1=(float)rangeAxis.valueToJava2D(y1 + stack1[1],dataArea,edge1);
      float transStack1=(float)rangeAxis.valueToJava2D(stack1[1],dataArea,edge1);
      float transStackLeft=(float)rangeAxis.valueToJava2D(adjStackLeft[1],dataArea,edge1);
      if (y0 >= 0.0) {
        double yleft=(y0 + y1) / 2.0 + stackLeft[1];
        float transYLeft=(float)rangeAxis.valueToJava2D(yleft,dataArea,edge1);
        left.moveTo((float)xx1,transY1);
        left.lineTo((float)xx1,transStack1);
        left.lineTo((float)xxLeft,transStackLeft);
        left.lineTo((float)xxLeft,transYLeft);
        left.closePath();
      }
 else {
        left.moveTo((float)xx1,transStack1);
        left.lineTo((float)xx1,transY1);
        left.lineTo((float)xxLeft,transStackLeft);
        left.closePath();
      }
      float transStackRight=(float)rangeAxis.valueToJava2D(adjStackRight[1],dataArea,edge1);
      if (y2 >= 0.0) {
        double yright=(y1 + y2) / 2.0 + stackRight[1];
        float transYRight=(float)rangeAxis.valueToJava2D(yright,dataArea,edge1);
        right.moveTo((float)xx1,transStack1);
        right.lineTo((float)xx1,transY1);
        right.lineTo((float)xxRight,transYRight);
        right.lineTo((float)xxRight,transStackRight);
        right.closePath();
      }
 else {
        right.moveTo((float)xx1,transStack1);
        right.lineTo((float)xx1,transY1);
        right.lineTo((float)xxRight,transStackRight);
        right.closePath();
      }
    }
 else {
      transY1=(float)rangeAxis.valueToJava2D(y1 + stack1[0],dataArea,edge1);
      float transStack1=(float)rangeAxis.valueToJava2D(stack1[0],dataArea,edge1);
      float transStackLeft=(float)rangeAxis.valueToJava2D(adjStackLeft[0],dataArea,edge1);
      if (y0 >= 0.0) {
        left.moveTo((float)xx1,transStack1);
        left.lineTo((float)xx1,transY1);
        left.lineTo((float)xxLeft,transStackLeft);
        left.clone();
      }
 else {
        double yleft=(y0 + y1) / 2.0 + stackLeft[0];
        float transYLeft=(float)rangeAxis.valueToJava2D(yleft,dataArea,edge1);
        left.moveTo((float)xx1,transY1);
        left.lineTo((float)xx1,transStack1);
        left.lineTo((float)xxLeft,transStackLeft);
        left.lineTo((float)xxLeft,transYLeft);
        left.closePath();
      }
      float transStackRight=(float)rangeAxis.valueToJava2D(adjStackRight[0],dataArea,edge1);
      if (y2 >= 0.0) {
        right.moveTo((float)xx1,transStack1);
        right.lineTo((float)xx1,transY1);
        right.lineTo((float)xxRight,transStackRight);
        right.closePath();
      }
 else {
        double yright=(y1 + y2) / 2.0 + stackRight[0];
        float transYRight=(float)rangeAxis.valueToJava2D(yright,dataArea,edge1);
        right.moveTo((float)xx1,transStack1);
        right.lineTo((float)xx1,transY1);
        right.lineTo((float)xxRight,transYRight);
        right.lineTo((float)xxRight,transStackRight);
        right.closePath();
      }
    }
    g2.setPaint(getItemPaint(row,column,selected));
    g2.setStroke(getItemStroke(row,column,selected));
    Paint itemPaint=getItemPaint(row,column,selected);
    if (pass == 0) {
      g2.setPaint(itemPaint);
      g2.fill(left);
      g2.fill(right);
    }
    if (entities != null) {
      GeneralPath gp=new GeneralPath(left);
      gp.append(right,false);
      entityArea=gp;
      addEntity(entities,entityArea,dataset,row,column,selected);
    }
  }
  /** 
 * Calculates the stacked value of the all series up to, but not including <code>series</code> for the specified category, <code>category</code>. It returns 0.0 if <code>series</code> is the first series, i.e. 0.
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param series  the series.
 * @param category  the category.
 * @return double returns a cumulative value for all series' values up tobut excluding <code>series</code> for Object <code>category</code>.
 */
  protected double getPreviousHeight(  CategoryDataset dataset,  int series,  int category){
    double result=0.0;
    Number n;
    double total=0.0;
    if (this.renderAsPercentages) {
      total=DataUtilities.calculateColumnTotal(dataset,category);
    }
    for (int i=0; i < series; i++) {
      n=dataset.getValue(i,category);
      if (n != null) {
        double v=n.doubleValue();
        if (this.renderAsPercentages) {
          v=v / total;
        }
        result+=v;
      }
    }
    return result;
  }
  /** 
 * Calculates the stacked values (one positive and one negative) of all series up to, but not including, <code>series</code> for the specified item. It returns [0.0, 0.0] if <code>series</code> is the first series.
 * @param dataset  the dataset (<code>null</code> not permitted).
 * @param series  the series index.
 * @param index  the item index.
 * @return An array containing the cumulative negative and positive valuesfor all series values up to but excluding <code>series</code> for <code>index</code>.
 */
  protected double[] getStackValues(  CategoryDataset dataset,  int series,  int index){
    double[] result=new double[2];
    for (int i=0; i < series; i++) {
      if (isSeriesVisible(i)) {
        double v=0.0;
        Number n=dataset.getValue(i,index);
        if (n != null) {
          v=n.doubleValue();
        }
        if (!Double.isNaN(v)) {
          if (v >= 0.0) {
            result[1]+=v;
          }
 else {
            result[0]+=v;
          }
        }
      }
    }
    return result;
  }
  /** 
 * Returns a pair of "stack" values calculated as the mean of the two specified stack value pairs.
 * @param stack1  the first stack pair.
 * @param stack2  the second stack pair.
 * @return A pair of average stack values.
 */
  private double[] averageStackValues(  double[] stack1,  double[] stack2){
    double[] result=new double[2];
    result[0]=(stack1[0] + stack2[0]) / 2.0;
    result[1]=(stack1[1] + stack2[1]) / 2.0;
    return result;
  }
  /** 
 * Calculates adjusted stack values from the supplied values.  The value is the mean of the supplied values, unless either of the supplied values is zero, in which case the adjusted value is zero also.
 * @param stack1  the first stack pair.
 * @param stack2  the second stack pair.
 * @return A pair of average stack values.
 */
  private double[] adjustedStackValues(  double[] stack1,  double[] stack2){
    double[] result=new double[2];
    if (stack1[0] == 0.0 || stack2[0] == 0.0) {
      result[0]=0.0;
    }
 else {
      result[0]=(stack1[0] + stack2[0]) / 2.0;
    }
    if (stack1[1] == 0.0 || stack2[1] == 0.0) {
      result[1]=0.0;
    }
 else {
      result[1]=(stack1[1] + stack2[1]) / 2.0;
    }
    return result;
  }
  /** 
 * Checks this instance for equality with an arbitrary object.
 * @param obj  the object (<code>null</code> not permitted).
 * @return A boolean.
 */
  public boolean equals(  Object obj){
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof StackedAreaRenderer)) {
      return false;
    }
    StackedAreaRenderer that=(StackedAreaRenderer)obj;
    if (this.renderAsPercentages != that.renderAsPercentages) {
      return false;
    }
    return super.equals(obj);
  }
}
