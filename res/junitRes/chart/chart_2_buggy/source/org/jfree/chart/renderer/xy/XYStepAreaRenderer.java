package org.jfree.chart.renderer.xy;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYCrosshairState;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.chart.util.PublicCloneable;
import org.jfree.chart.util.ShapeUtilities;
import org.jfree.data.xy.XYDataset;
/** 
 * A step chart renderer that fills the area between the step and the x-axis. The example shown here is generated by the <code>XYStepAreaRendererDemo1.java</code> program included in the JFreeChart demo collection: <br><br> <img src="../../../../../images/XYStepAreaRendererSample.png" alt="XYStepAreaRendererSample.png" />
 */
public class XYStepAreaRenderer extends AbstractXYItemRenderer implements XYItemRenderer, Cloneable, PublicCloneable, Serializable {
  /** 
 * For serialization. 
 */
  private static final long serialVersionUID=-7311560779702649635L;
  /** 
 * Useful constant for specifying the type of rendering (shapes only). 
 */
  public static final int SHAPES=1;
  /** 
 * Useful constant for specifying the type of rendering (area only). 
 */
  public static final int AREA=2;
  /** 
 * Useful constant for specifying the type of rendering (area and shapes).
 */
  public static final int AREA_AND_SHAPES=3;
  /** 
 * A flag indicating whether or not shapes are drawn at each XY point. 
 */
  private boolean shapesVisible;
  /** 
 * A flag that controls whether or not shapes are filled for ALL series. 
 */
  private boolean shapesFilled;
  /** 
 * A flag indicating whether or not Area are drawn at each XY point. 
 */
  private boolean plotArea;
  /** 
 * A flag that controls whether or not the outline is shown. 
 */
  private boolean showOutline;
  /** 
 * Area of the complete series 
 */
  protected transient Polygon pArea=null;
  /** 
 * The value on the range axis which defines the 'lower' border of the area.
 */
  private double rangeBase;
  /** 
 * Constructs a new renderer.
 */
  public XYStepAreaRenderer(){
    this(AREA);
  }
  /** 
 * Constructs a new renderer.
 * @param type  the type of the renderer.
 */
  public XYStepAreaRenderer(  int type){
    this(type,null,null);
  }
  /** 
 * Constructs a new renderer. <p> To specify the type of renderer, use one of the constants: AREA, SHAPES or AREA_AND_SHAPES.
 * @param type  the type of renderer.
 * @param toolTipGenerator  the tool tip generator to use(<code>null</code> permitted).
 * @param urlGenerator  the URL generator (<code>null</code> permitted).
 */
  public XYStepAreaRenderer(  int type,  XYToolTipGenerator toolTipGenerator,  XYURLGenerator urlGenerator){
    super();
    setBaseToolTipGenerator(toolTipGenerator);
    setBaseURLGenerator(urlGenerator);
    if (type == AREA) {
      this.plotArea=true;
    }
 else {
      if (type == SHAPES) {
        this.shapesVisible=true;
      }
 else {
        if (type == AREA_AND_SHAPES) {
          this.plotArea=true;
          this.shapesVisible=true;
        }
      }
    }
    this.showOutline=false;
  }
  /** 
 * Returns a flag that controls whether or not outlines of the areas are drawn.
 * @return The flag.
 * @see #setOutline(boolean)
 */
  public boolean isOutline(){
    return this.showOutline;
  }
  /** 
 * Sets a flag that controls whether or not outlines of the areas are drawn, and sends a                                                                                                                                                                     {@link RendererChangeEvent} to all registeredlisteners.
 * @param show  the flag.
 * @see #isOutline()
 */
  public void setOutline(  boolean show){
    this.showOutline=show;
    fireChangeEvent();
  }
  /** 
 * Returns true if shapes are being plotted by the renderer.
 * @return <code>true</code> if shapes are being plotted by the renderer.
 * @see #setShapesVisible(boolean)
 */
  public boolean getShapesVisible(){
    return this.shapesVisible;
  }
  /** 
 * Sets the flag that controls whether or not shapes are displayed for each data item, and sends a                                                                                                                                                                     {@link RendererChangeEvent} to all registeredlisteners.
 * @param flag  the flag.
 * @see #getShapesVisible()
 */
  public void setShapesVisible(  boolean flag){
    this.shapesVisible=flag;
    fireChangeEvent();
  }
  /** 
 * Returns the flag that controls whether or not the shapes are filled.
 * @return A boolean.
 * @see #setShapesFilled(boolean)
 */
  public boolean isShapesFilled(){
    return this.shapesFilled;
  }
  /** 
 * Sets the 'shapes filled' for ALL series and sends a                                                                                                                                                                    {@link RendererChangeEvent} to all registered listeners.
 * @param filled  the flag.
 * @see #isShapesFilled()
 */
  public void setShapesFilled(  boolean filled){
    this.shapesFilled=filled;
    fireChangeEvent();
  }
  /** 
 * Returns true if Area is being plotted by the renderer.
 * @return <code>true</code> if Area is being plotted by the renderer.
 * @see #setPlotArea(boolean)
 */
  public boolean getPlotArea(){
    return this.plotArea;
  }
  /** 
 * Sets a flag that controls whether or not areas are drawn for each data item and sends a                                                                                                                                                                     {@link RendererChangeEvent} to all registeredlisteners.
 * @param flag  the flag.
 * @see #getPlotArea()
 */
  public void setPlotArea(  boolean flag){
    this.plotArea=flag;
    fireChangeEvent();
  }
  /** 
 * Returns the value on the range axis which defines the 'lower' border of the area.
 * @return <code>double</code> the value on the range axis which definesthe 'lower' border of the area.
 * @see #setRangeBase(double)
 */
  public double getRangeBase(){
    return this.rangeBase;
  }
  /** 
 * Sets the value on the range axis which defines the default border of the area, and sends a                                                                                                                                                                     {@link RendererChangeEvent} to all registeredlisteners.  E.g. setRangeBase(Double.NEGATIVE_INFINITY) lets areas always reach the lower border of the plotArea.
 * @param val  the value on the range axis which defines the default borderof the area.
 * @see #getRangeBase()
 */
  public void setRangeBase(  double val){
    this.rangeBase=val;
    fireChangeEvent();
  }
  /** 
 * Initialises the renderer.  Here we calculate the Java2D y-coordinate for zero, since all the bars have their bases fixed at zero.
 * @param g2  the graphics device.
 * @param dataArea  the area inside the axes.
 * @param plot  the plot.
 * @param data  the data.
 * @param info  an optional info collection object to return data back tothe caller.
 * @return The number of passes required by the renderer.
 */
  public XYItemRendererState initialise(  Graphics2D g2,  Rectangle2D dataArea,  XYPlot plot,  XYDataset data,  PlotRenderingInfo info){
    XYItemRendererState state=super.initialise(g2,dataArea,plot,data,info);
    state.setProcessVisibleItemsOnly(false);
    return state;
  }
  /** 
 * Draws the visual representation of a single data item.
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the area within which the data is being drawn.
 * @param plot  the plot (can be used to obtain standard color informationetc).
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the dataset.
 * @param series  the series index (zero-based).
 * @param item  the item index (zero-based).
 * @param pass  the pass index.
 */
  public void drawItem(  Graphics2D g2,  XYItemRendererState state,  Rectangle2D dataArea,  XYPlot plot,  ValueAxis domainAxis,  ValueAxis rangeAxis,  XYDataset dataset,  int series,  int item,  boolean selected,  int pass){
    PlotOrientation orientation=plot.getOrientation();
    int itemCount=dataset.getItemCount(series);
    Paint paint=getItemPaint(series,item,selected);
    Stroke seriesStroke=getItemStroke(series,item,selected);
    g2.setPaint(paint);
    g2.setStroke(seriesStroke);
    double x1=dataset.getXValue(series,item);
    double y1=dataset.getYValue(series,item);
    double x=x1;
    double y=Double.isNaN(y1) ? getRangeBase() : y1;
    double transX1=domainAxis.valueToJava2D(x,dataArea,plot.getDomainAxisEdge());
    double transY1=rangeAxis.valueToJava2D(y,dataArea,plot.getRangeAxisEdge());
    transY1=restrictValueToDataArea(transY1,plot,dataArea);
    if (this.pArea == null && !Double.isNaN(y1)) {
      this.pArea=new Polygon();
      double transY2=rangeAxis.valueToJava2D(getRangeBase(),dataArea,plot.getRangeAxisEdge());
      transY2=restrictValueToDataArea(transY2,plot,dataArea);
      if (orientation == PlotOrientation.VERTICAL) {
        this.pArea.addPoint((int)transX1,(int)transY2);
      }
 else {
        if (orientation == PlotOrientation.HORIZONTAL) {
          this.pArea.addPoint((int)transY2,(int)transX1);
        }
      }
    }
    double transX0=0;
    double transY0=restrictValueToDataArea(getRangeBase(),plot,dataArea);
    double x0;
    double y0;
    if (item > 0) {
      x0=dataset.getXValue(series,item - 1);
      y0=Double.isNaN(y1) ? y1 : dataset.getYValue(series,item - 1);
      x=x0;
      y=Double.isNaN(y0) ? getRangeBase() : y0;
      transX0=domainAxis.valueToJava2D(x,dataArea,plot.getDomainAxisEdge());
      transY0=rangeAxis.valueToJava2D(y,dataArea,plot.getRangeAxisEdge());
      transY0=restrictValueToDataArea(transY0,plot,dataArea);
      if (Double.isNaN(y1)) {
        transX1=transX0;
        transY0=transY1;
      }
      if (transY0 != transY1) {
        if (orientation == PlotOrientation.VERTICAL) {
          this.pArea.addPoint((int)transX1,(int)transY0);
        }
 else {
          if (orientation == PlotOrientation.HORIZONTAL) {
            this.pArea.addPoint((int)transY0,(int)transX1);
          }
        }
      }
    }
    Shape shape=null;
    if (!Double.isNaN(y1)) {
      if (orientation == PlotOrientation.VERTICAL) {
        this.pArea.addPoint((int)transX1,(int)transY1);
      }
 else {
        if (orientation == PlotOrientation.HORIZONTAL) {
          this.pArea.addPoint((int)transY1,(int)transX1);
        }
      }
      if (getShapesVisible()) {
        shape=getItemShape(series,item,selected);
        if (orientation == PlotOrientation.VERTICAL) {
          shape=ShapeUtilities.createTranslatedShape(shape,transX1,transY1);
        }
 else {
          if (orientation == PlotOrientation.HORIZONTAL) {
            shape=ShapeUtilities.createTranslatedShape(shape,transY1,transX1);
          }
        }
        if (isShapesFilled()) {
          g2.fill(shape);
        }
 else {
          g2.draw(shape);
        }
      }
 else {
        if (orientation == PlotOrientation.VERTICAL) {
          shape=new Rectangle2D.Double(transX1 - 2,transY1 - 2,4.0,4.0);
        }
 else {
          if (orientation == PlotOrientation.HORIZONTAL) {
            shape=new Rectangle2D.Double(transY1 - 2,transX1 - 2,4.0,4.0);
          }
        }
      }
    }
    if (getPlotArea() && item > 0 && this.pArea != null && (item == (itemCount - 1) || Double.isNaN(y1))) {
      double transY2=rangeAxis.valueToJava2D(getRangeBase(),dataArea,plot.getRangeAxisEdge());
      transY2=restrictValueToDataArea(transY2,plot,dataArea);
      if (orientation == PlotOrientation.VERTICAL) {
        this.pArea.addPoint((int)transX1,(int)transY2);
      }
 else {
        if (orientation == PlotOrientation.HORIZONTAL) {
          this.pArea.addPoint((int)transY2,(int)transX1);
        }
      }
      g2.fill(this.pArea);
      if (isOutline()) {
        g2.setStroke(plot.getOutlineStroke());
        g2.setPaint(plot.getOutlinePaint());
        g2.draw(this.pArea);
      }
      this.pArea=null;
    }
    if (!Double.isNaN(y1)) {
      int domainAxisIndex=plot.getDomainAxisIndex(domainAxis);
      int rangeAxisIndex=plot.getRangeAxisIndex(rangeAxis);
      XYCrosshairState crosshairState=state.getCrosshairState();
      updateCrosshairValues(crosshairState,x1,y1,domainAxisIndex,rangeAxisIndex,transX1,transY1,orientation);
    }
    EntityCollection entities=state.getEntityCollection();
    if (entities != null) {
      addEntity(entities,shape,dataset,series,item,selected,transX1,transY1);
    }
  }
  /** 
 * Tests this renderer for equality with an arbitrary object.
 * @param obj  the object (<code>null</code> permitted).
 * @return A boolean.
 */
  public boolean equals(  Object obj){
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof XYStepAreaRenderer)) {
      return false;
    }
    XYStepAreaRenderer that=(XYStepAreaRenderer)obj;
    if (this.showOutline != that.showOutline) {
      return false;
    }
    if (this.shapesVisible != that.shapesVisible) {
      return false;
    }
    if (this.shapesFilled != that.shapesFilled) {
      return false;
    }
    if (this.plotArea != that.plotArea) {
      return false;
    }
    if (this.rangeBase != that.rangeBase) {
      return false;
    }
    return super.equals(obj);
  }
  /** 
 * Returns a clone of the renderer.
 * @return A clone.
 * @throws CloneNotSupportedException  if the renderer cannot be cloned.
 */
  public Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
  /** 
 * Helper method which returns a value if it lies inside the visible dataArea and otherwise the corresponding coordinate on the border of the dataArea. The PlotOrientation is taken into account. Useful to avoid possible sun.dc.pr.PRException: endPath: bad path which occurs when trying to draw lines/shapes which in large part lie outside of the visible dataArea.
 * @param value the value which shall be
 * @param dataArea  the area within which the data is being drawn.
 * @param plot  the plot (can be used to obtain standard colorinformation etc).
 * @return <code>double</code> value inside the data area.
 */
  protected static double restrictValueToDataArea(  double value,  XYPlot plot,  Rectangle2D dataArea){
    double min=0;
    double max=0;
    if (plot.getOrientation() == PlotOrientation.VERTICAL) {
      min=dataArea.getMinY();
      max=dataArea.getMaxY();
    }
 else {
      if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
        min=dataArea.getMinX();
        max=dataArea.getMaxX();
      }
    }
    if (value < min) {
      value=min;
    }
 else {
      if (value > max) {
        value=max;
      }
    }
    return value;
  }
}
